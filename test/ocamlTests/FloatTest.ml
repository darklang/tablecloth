open Tablecloth
open AlcoJest

let suite =
 suite "Float" (fun () ->
   let open Float in
test "absolute(8.)" (fun () -> expect (Float.absolute 8.) |> toEqual Eq.float 8.) ; 
test "absolute(-7.)" (fun () -> expect (Float.absolute -7.) |> toEqual Eq.float 7.) ; 
test "absolute(0.)" (fun () -> expect (Float.absolute 0.) |> toEqual Eq.float 0.) ; 
test "add(3.14,3.14)" (fun () -> expect (Float.add 3.14 3.14) |> toEqual Eq.float 6.28) ; 
test "clamp(5.,~lower=0.,~upper=8.)" (fun () -> expect (Float.clamp 5. ~lower:0. ~upper:8.) |> toEqual Eq.float 5.) ; 
test "clamp(9.,~lower=0.,~upper=8.)" (fun () -> expect (Float.clamp 9. ~lower:0. ~upper:8.) |> toEqual Eq.float 8.) ; 
test "clamp(1.,~lower=2.,~upper=8.)" (fun () -> expect (Float.clamp 1. ~lower:2. ~upper:8.) |> toEqual Eq.float 2.) ; 
test "clamp(5.,~lower=-10.,~upper=-5.)" (fun () -> expect (Float.clamp 5. ~lower:-10. ~upper:-5.) |> toEqual Eq.float -5.) ; 
test "clamp(-15.,~lower=-10.,~upper=-5.)" (fun () -> expect (Float.clamp -15. ~lower:-10. ~upper:-5.) |> toEqual Eq.float -10.) ; 
test "clamp(-6.6,~lower=-7.9,~upper=nan)" (fun () -> expect (Float.clamp -6.6 ~lower:-7.9 ~upper:nan) |> toEqual Eq.float NaN) ; 
test "clamp(-6.6,~lower=nan,~upper=0.)" (fun () -> expect (Float.clamp -6.6 ~lower:nan ~upper:0.) |> toEqual Eq.float NaN) ; 
test "clamp(nan,~lower=2.,~upper=8.)" (fun () -> expect (Float.clamp nan ~lower:2. ~upper:8.) |> toEqual Eq.float NaN) ; 
test "clamp(3.,~lower=7.,~upper= 1.)" (fun () -> expect (fun () -> clamp 3. ~lower:7. ~upper: 1.) |> toThrow); 
test "atan(0.)" (fun () -> expect (Float.atan 0.) |> toEqual Eq.radians 0.) ; 
test "atan(1. /. 1.)" (fun () -> expect (Float.atan 1. /. 1.) |> toEqual Eq.radians 0.7853981633974483) ; 
test "atan(1. /. -1.)" (fun () -> expect (Float.atan 1. /. -1.) |> toEqual Eq.radians -0.7853981633974483) ; 
test "atan(-1. /. -1.)" (fun () -> expect (Float.atan -1. /. -1.) |> toEqual Eq.radians 0.7853981633974483) ; 
test "atan(-1. /. 1.)" (fun () -> expect (Float.atan -1. /. 1.) |> toEqual Eq.radians -0.7853981633974483) ; 
test "atan2(~y=0.,~x=0.)" (fun () -> expect (Float.atan2 ~y:0. ~x:0.) |> toEqual Eq.radians 0.) ; 
test "atan2(~y=1.,~x=1.)" (fun () -> expect (Float.atan2 ~y:1. ~x:1.) |> toEqual Eq.radians 0.7853981633974483) ; 
test "atan2(~y=1.,~x=-1.)" (fun () -> expect (Float.atan2 ~y:1. ~x:-1.) |> toEqual Eq.radians 2.356194490192345) ; 
test "atan2(~y=-1.,~x=-1.)" (fun () -> expect (Float.atan2 ~y:-1. ~x:-1.) |> toEqual Eq.radians -2.356194490192345) ; 
test "atan2(~y=-1.,~x=1.)" (fun () -> expect (Float.atan2 ~y:-1. ~x:1.) |> toEqual Eq.radians -0.7853981633974483) ; 
test "ceiling(1.2)" (fun () -> expect (Float.ceiling 1.2) |> toEqual Eq.float 2.) ; 
test "ceiling(1.5)" (fun () -> expect (Float.ceiling 1.5) |> toEqual Eq.float 2.) ; 
test "ceiling(1.8)" (fun () -> expect (Float.ceiling 1.8) |> toEqual Eq.float 2.) ; 
test "ceiling(-1.2)" (fun () -> expect (Float.ceiling -1.2) |> toEqual Eq.float -1.) ; 
test "ceiling(-1.5)" (fun () -> expect (Float.ceiling -1.5) |> toEqual Eq.float -1.) ; 
test "ceiling(-1.8)" (fun () -> expect (Float.ceiling -1.8) |> toEqual Eq.float -1.) ; 
test "cos(degrees(60.))" (fun () -> expect (Float.cos degrees(60.)) |> toEqual Eq.float 0.5) ; 
test "cos(radians(pi /. 3.))" (fun () -> expect (Float.cos radians(pi /. 3.)) |> toEqual Eq.float 0.5) ; 
test "degrees(180.)" (fun () -> expect (Float.degrees 180.) |> toEqual Eq.radians pi) ; 
test "divide(3.14,~by=2.)" (fun () -> expect (Float.divide 3.14 ~by:2.) |> toEqual Eq.float 1.57) ; 
test "divide(3.14,~by=0.)" (fun () -> expect (Float.divide 3.14 ~by:0.) |> toEqual Eq.float infinity) ; 
test "divide(3.14,~by=-0.)" (fun () -> expect (Float.divide 3.14 ~by:-0.) |> toEqual Eq.float negativeInfinity) ; 
test "floor(1.2)" (fun () -> expect (Float.floor 1.2) |> toEqual Eq.float 1.) ; 
test "floor(1.5)" (fun () -> expect (Float.floor 1.5) |> toEqual Eq.float 1.) ; 
test "floor(1.8)" (fun () -> expect (Float.floor 1.8) |> toEqual Eq.float 1.) ; 
test "floor(-1.2)" (fun () -> expect (Float.floor -1.2) |> toEqual Eq.float -2.) ; 
test "floor(-1.5)" (fun () -> expect (Float.floor -1.5) |> toEqual Eq.float -2.) ; 
test "floor(-1.8)" (fun () -> expect (Float.floor -1.8) |> toEqual Eq.float -2.) ; 
test "fromInt(5)" (fun () -> expect (Float.fromInt 5) |> toEqual Eq.float 5.0) ; 
test "fromInt(0)" (fun () -> expect (Float.fromInt 0) |> toEqual Eq.float 0.0) ; 
test "fromInt(-7)" (fun () -> expect (Float.fromInt -7) |> toEqual Eq.float -7.0) ; 
test "fromString("NaN")" (fun () -> expect (Float.fromString "NaN") |> toEqual (let open Eq in option float) Some(Js.Float._NaN),) ; 
test "fromString("nan")" (fun () -> expect (Float.fromString "nan") |> toEqual (let open Eq in option float) Some(Js.Float._NaN)) ; 
test "fromString("Infinity")" (fun () -> expect (Float.fromString "Infinity") |> toEqual (let open Eq in option float) Some(infinity)) ; 
test "fromString("infinity")" (fun () -> expect (Float.fromString "infinity") |> toEqual (let open Eq in option float) None) ; 
test "fromString("55")" (fun () -> expect (Float.fromString "55") |> toEqual (let open Eq in option float) Some(55.)) ; 
test "fromString("-100")" (fun () -> expect (Float.fromString "-100") |> toEqual (let open Eq in option float) Some(-100.)) ; 
test "fromString("not number")" (fun () -> expect (Float.fromString "not number") |> toEqual (let open Eq in option float) None) ; 
test "hypotenuse(3.,4.)" (fun () -> expect (Float.hypotenuse 3. 4.) |> toEqual Eq.float 5.) ; 
test "inRange(3.,~lower=2.,~upper=4.)" (fun () -> expect (Float.inRange 3. ~lower:2. ~upper:4.) |> toEqual Eq.bool true) ; 
test "inRange(8.,~lower=2.,~upper=4.)" (fun () -> expect (Float.inRange 8. ~lower:2. ~upper:4.) |> toEqual Eq.bool false) ; 
test "inRange(1.,~lower= 2.,~upper=4.)" (fun () -> expect (Float.inRange 1. ~lower: 2. ~upper:4.) |> toEqual Eq.bool false) ; 
test "inRange(2.,~lower=1.,~upper=2.)" (fun () -> expect (Float.inRange 2. ~lower:1. ~upper:2.) |> toEqual Eq.bool false) ; 
test "inRange(-6.6,~lower=-7.9,~upper=-5.2)" (fun () -> expect (Float.inRange -6.6 ~lower:-7.9 ~upper:-5.2) |> toEqual Eq.bool true) ; 
test "inRange(-6.6,~lower=-7.9,~upper=nan)" (fun () -> expect (Float.inRange -6.6 ~lower:-7.9 ~upper:nan) |> toEqual Eq.bool false) ; 
test "inRange(-6.6,~lower=nan,~upper=0.)" (fun () -> expect (Float.inRange -6.6 ~lower:nan ~upper:0.) |> toEqual Eq.bool false) ; 
test "inRange(nan,~lower=2.,~upper=8.)" (fun () -> expect (Float.inRange nan ~lower:2. ~upper:8.) |> toEqual Eq.bool false) ; 
test "inRange(3.,~lower=7.,~upper=1.)" (fun () -> expect (fun () -> inRange 3. ~lower:7. ~upper:1.) |> toThrow); 
test "isFinite(infinity)" (fun () -> expect (Float.isFinite infinity) |> toEqual Eq.bool false) ; 
test "isFinite(negativeInfinity)" (fun () -> expect (Float.isFinite negativeInfinity) |> toEqual Eq.bool false) ; 
test "isFinite(nan)" (fun () -> expect (Float.isFinite nan) |> toEqual Eq.bool false) ; 
test "isFinite(-5.)" (fun () -> expect (Float.isFinite -5.) |> toEqual Eq.bool true) ; 
test "isFinite(-0.314)" (fun () -> expect (Float.isFinite -0.314) |> toEqual Eq.bool true) ; 
test "isFinite(0.)" (fun () -> expect (Float.isFinite 0.) |> toEqual Eq.bool true) ; 
test "isFinite(3.14)" (fun () -> expect (Float.isFinite 3.14) |> toEqual Eq.bool true) ; 
test "isInfinite(infinity)" (fun () -> expect (Float.isInfinite infinity) |> toEqual Eq.bool true) ; 
test "isInfinite(negativeInfinity)" (fun () -> expect (Float.isInfinite negativeInfinity) |> toEqual Eq.bool true) ; 
test "isInfinite(nan)" (fun () -> expect (Float.isInfinite nan) |> toEqual Eq.bool false) ; 
test "isInfinite(-5.)" (fun () -> expect (Float.isInfinite -5.) |> toEqual Eq.bool false) ; 
test "isInfinite(-0.314)" (fun () -> expect (Float.isInfinite -0.314) |> toEqual Eq.bool false) ; 
test "isInfinite(0.)" (fun () -> expect (Float.isInfinite 0.) |> toEqual Eq.bool false) ; 
test "isInfinite(3.14)" (fun () -> expect (Float.isInfinite 3.14) |> toEqual Eq.bool false) ; 
test "isInteger(5.0)" (fun () -> expect (Float.isInteger 5.0) |> toEqual Eq.bool true) ; 
test "isInteger(pi)" (fun () -> expect (Float.isInteger pi) |> toEqual Eq.bool false) ; 
test "isNaN(nan)" (fun () -> expect (Float.isNaN nan) |> toEqual Eq.bool true) ; 
test "isNaN(91.4)" (fun () -> expect (Float.isNaN 91.4) |> toEqual Eq.bool false) ; 
test "log(100.,~base=10.)" (fun () -> expect (Float.log 100. ~base:10.) |> toEqual Eq.float 2.) ; 
test "log(256.,~base=2.)" (fun () -> expect (Float.log 256. ~base:2.) |> toEqual Eq.float 8.) ; 
test "log(0.,~base=10.)" (fun () -> expect (Float.log 0. ~base:10.) |> toEqual Eq.float negativeInfinity) ; 
test "maximum(7.,9.)" (fun () -> expect (Float.maximum 7. 9.) |> toEqual Eq.float 9.) ; 
test "maximum(-4.,-1.)" (fun () -> expect (Float.maximum -4. -1.) |> toEqual Eq.float -1.) ; 
test "maximum(7.,nan)" (fun () -> expect (Float.maximum 7. nan) |> toEqual Eq.float NaN) ; 
test "maximum(7.,infinity)" (fun () -> expect (Float.maximum 7. infinity) |> toEqual Eq.float infinity) ; 
test "maximum(7.,negativeInfinity)" (fun () -> expect (Float.maximum 7. negativeInfinity) |> toEqual Eq.float 7.) ; 
test "minimum(7.,9.)" (fun () -> expect (Float.minimum 7. 9.) |> toEqual Eq.float 7.) ; 
test "minimum(-4.,-1.)" (fun () -> expect (Float.minimum -4. -1.) |> toEqual Eq.float -4.) ; 
test "minimum(7.,nan)" (fun () -> expect (Float.minimum 7. nan) |> toEqual Eq.float NaN) ; 
test "minimum(7.,infinity)" (fun () -> expect (Float.minimum 7. infinity) |> toEqual Eq.float 7.) ; 
test "minimum(7.,negativeInfinity)" (fun () -> expect (Float.minimum 7. negativeInfinity) |> toEqual Eq.float negativeInfinity) ; 
test "multiply(2.,7.)" (fun () -> expect (Float.multiply 2. 7.) |> toEqual Eq.float 14.) ; 
test "negate(8.)" (fun () -> expect (Float.negate 8.) |> toEqual Eq.float -8.) ; 
test "negate(-7.)" (fun () -> expect (Float.negate -7.) |> toEqual Eq.float 7.) ; 
test "negate(0.)" (fun () -> expect (Float.negate 0.) |> toEqual Eq.float -0.) ; 
test "power(~base=7.,~exponent=3.)" (fun () -> expect (Float.power ~base:7. ~exponent:3.) |> toEqual Eq.float 343.) ; 
test "power(~base=0.,~exponent=3.)" (fun () -> expect (Float.power ~base:0. ~exponent:3.) |> toEqual Eq.float 0.) ; 
test "power(~base=7.,~exponent=0.)" (fun () -> expect (Float.power ~base:7. ~exponent:0.) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Zero,1.2)" (fun () -> expect (Float.round ~direction:#Zero 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Zero,1.5)" (fun () -> expect (Float.round ~direction:#Zero 1.5) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Zero,1.8)" (fun () -> expect (Float.round ~direction:#Zero 1.8) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Zero,-1.2)" (fun () -> expect (Float.round ~direction:#Zero -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Zero,-1.5)" (fun () -> expect (Float.round ~direction:#Zero -1.5) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Zero,-1.8)" (fun () -> expect (Float.round ~direction:#Zero -1.8) |> toEqual Eq.float -1.) ; 
test "round(~direction=#AwayFromZero,1.2)" (fun () -> expect (Float.round ~direction:#AwayFromZero 1.2) |> toEqual Eq.float 2.) ; 
test "round(~direction=#AwayFromZero,1.5)" (fun () -> expect (Float.round ~direction:#AwayFromZero 1.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#AwayFromZero,1.8)" (fun () -> expect (Float.round ~direction:#AwayFromZero 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#AwayFromZero,-1.2)" (fun () -> expect (Float.round ~direction:#AwayFromZero -1.2) |> toEqual Eq.float -2.) ; 
test "round(~direction=#AwayFromZero,-1.5)" (fun () -> expect (Float.round ~direction:#AwayFromZero -1.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#AwayFromZero,-1.8)" (fun () -> expect (Float.round ~direction:#AwayFromZero -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Up,1.2)" (fun () -> expect (Float.round ~direction:#Up 1.2) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Up,1.5)" (fun () -> expect (Float.round ~direction:#Up 1.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Up,1.8)" (fun () -> expect (Float.round ~direction:#Up 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Up,-1.2)" (fun () -> expect (Float.round ~direction:#Up -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Up,-1.5)" (fun () -> expect (Float.round ~direction:#Up -1.5) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Up,-1.8)" (fun () -> expect (Float.round ~direction:#Up -1.8) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Down,1.2)" (fun () -> expect (Float.round ~direction:#Down 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Down,1.5)" (fun () -> expect (Float.round ~direction:#Down 1.5) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Down,1.8)" (fun () -> expect (Float.round ~direction:#Down 1.8) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Down,-1.2)" (fun () -> expect (Float.round ~direction:#Down -1.2) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Down,-1.5)" (fun () -> expect (Float.round ~direction:#Down -1.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Down,-1.8)" (fun () -> expect (Float.round ~direction:#Down -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#Zero),1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#Zero),1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) 1.5) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#Zero),1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#Zero),-1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#Zero),-1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) -1.5) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#Zero),-1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Zero) -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#AwayFromZero),1.2)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#AwayFromZero),1.5)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) 1.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#AwayFromZero),1.8)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#AwayFromZero),-1.2)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#AwayFromZero),-1.5)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) -1.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#AwayFromZero),-1.8)" (fun () -> expect (Float.round ~direction:#Closest(#AwayFromZero) -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#Up),1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Up) 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#Up),1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Up) 1.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#Up),1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Up) 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#Up),-1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Up) -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#Up),-1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Up) -1.5) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#Up),-1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Up) -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#Down),1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Down) 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#Down),1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Down) 1.5) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#Down),1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Down) 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#Down),-1.2)" (fun () -> expect (Float.round ~direction:#Closest(#Down) -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#Down),-1.5)" (fun () -> expect (Float.round ~direction:#Closest(#Down) -1.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#Down),-1.8)" (fun () -> expect (Float.round ~direction:#Closest(#Down) -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#ToEven),1.2)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 1.2) |> toEqual Eq.float 1.) ; 
test "round(~direction=#Closest(#ToEven),1.5)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 1.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#ToEven),1.8)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 1.8) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#ToEven),2.2)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 2.2) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#ToEven),2.5)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 2.5) |> toEqual Eq.float 2.) ; 
test "round(~direction=#Closest(#ToEven),2.8)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) 2.8) |> toEqual Eq.float 3.) ; 
test "round(~direction=#Closest(#ToEven),-1.2)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -1.2) |> toEqual Eq.float -1.) ; 
test "round(~direction=#Closest(#ToEven),-1.5)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -1.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#ToEven),-1.8)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -1.8) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#ToEven),-2.2)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -2.2) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#ToEven),-2.5)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -2.5) |> toEqual Eq.float -2.) ; 
test "round(~direction=#Closest(#ToEven),-2.8)" (fun () -> expect (Float.round ~direction:#Closest(#ToEven) -2.8) |> toEqual Eq.float -3.) ; 
test "radians(pi)" (fun () -> expect (Float.radians pi) |> toEqual Eq.radians pi) ; 
test "sin(degrees(30.))" (fun () -> expect (Float.sin degrees(30.)) |> toEqual Eq.float 0.5) ; 
test "sin(radians(pi /. 6.))" (fun () -> expect (Float.sin radians(pi /. 6.)) |> toEqual Eq.float 0.5) ; 
test "squareRoot(4.)" (fun () -> expect (Float.squareRoot 4.) |> toEqual Eq.float 2.) ; 
test "squareRoot(20.25)" (fun () -> expect (Float.squareRoot 20.25) |> toEqual Eq.float 4.5) ; 
test "squareRoot(-1.)" (fun () -> expect (Float.squareRoot -1.) |> toEqual Eq.float NaN) ; 
test "subtract(4.,3.)" (fun () -> expect (Float.subtract 4. 3.) |> toEqual Eq.float 1.) ; 
test "tan(degrees(45.))" (fun () -> expect (Float.tan degrees(45.)) |> toEqual Eq.float 0.9999999999999999) ; 
test "tan(radians(pi /. 4.))" (fun () -> expect (Float.tan radians(pi /. 4.)) |> toEqual Eq.float 0.9999999999999999) ; 
test "tan(0.)" (fun () -> expect (Float.tan 0.) |> toEqual Eq.float 0.) ; 
test "toInt(5.)" (fun () -> expect (Float.toInt 5.) |> toEqual (let open Eq in option int) Some(5)) ; 
test "toInt(5.3)" (fun () -> expect (Float.toInt 5.3) |> toEqual (let open Eq in option int) Some(5)) ; 
test "toInt(0.)" (fun () -> expect (Float.toInt 0.) |> toEqual (let open Eq in option int) Some(0)) ; 
test "toInt(-7.)" (fun () -> expect (Float.toInt -7.) |> toEqual (let open Eq in option int) Some(-7)) ; 
test "toInt(nan)" (fun () -> expect (Float.toInt nan) |> toEqual (let open Eq in option int) None) ; 
test "toInt(infinity)" (fun () -> expect (Float.toInt infinity) |> toEqual (let open Eq in option int) None) ; 
test "toInt(negativeInfinity)" (fun () -> expect (Float.toInt negativeInfinity) |> toEqual (let open Eq in option int) None) ; 
test "truncate(1.2)" (fun () -> expect (Float.truncate 1.2) |> toEqual Eq.float 1.) ; 
test "truncate(1.5)" (fun () -> expect (Float.truncate 1.5) |> toEqual Eq.float 1.) ; 
test "truncate(1.8)" (fun () -> expect (Float.truncate 1.8) |> toEqual Eq.float 1.) ; 
test "truncate(-1.2)" (fun () -> expect (Float.truncate -1.2) |> toEqual Eq.float -1.) ; 
test "truncate(-1.5)" (fun () -> expect (Float.truncate -1.5) |> toEqual Eq.float -1.) ; 
test "truncate(-1.8)" (fun () -> expect (Float.truncate -1.8) |> toEqual Eq.float -1.) ; 
test "turns(1.)" (fun () -> expect (Float.turns 1.) |> toEqual Eq.radians 2. *. pi) ; 
)